<%# =========================================================================================================%>


	<body>





		<script src="scripts/three.js"></script>

		<script src="scripts/Projector.js"></script>
		<script src="scripts/CanvasRenderer.js"></script>
		<script src="scripts/app.js"></script>
<div class="row1" style="">

		<span class ="col-xs-9"  id="openfirspage" style="position:absolute;  border:none; background-color:rgba(0,0,0,0);"><i class="fa fa-bars openfirspage"  aria-hidden="true" style="font-size:50px; color:white; margin:60px;"></i></span>




</div>
<div class="row2" style="display:none">

		<span class ="col-xs-9"  id="close" style="dsplay:none; position:absolute;  border:none; background-color:rgba(0,0,0,0);"><i class="fa fa-times "  aria-hidden="true" style="font-size:50px; color:white; margin:60px;"></i></span>




</div>

		<script type="text/javascript">

	var close = document.getElementById( 'close' );
				 close.addEventListener( 'click', ()=>{
console.log('pingaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
				 	$('#container1').fadeOut(1500,()=>{
					$('#world').fadeIn(1900);
					$('.row1').fadeIn();
					$('.row2').fadeOut();


});
				 }, false );

				 </script>
<div class="row" style="">
<h2 class="col-xs-offset-3 col-xs-7" id="quote" style="position:absolute; color:#f8f8f8; margin-top:470px;"></h2>

</div>

<script type="text/javascript">
(function() {
	'use strict';
	/* 	'To actually be able to display anything with Three.js, we need three things:
		A scene, a camera, and a renderer so we can render the scene with the camera.'

	   		- https://threejs.org/docs/#Manual/Introduction/Creating_a_scene 		*/

	var scene, camera, renderer;

	/* We need this stuff too */
	var container, aspectRatio,
		HEIGHT, WIDTH, fieldOfView,
		nearPlane, farPlane,
		mouseX, mouseY, windowHalfX,
		windowHalfY, geometry,
		starStuff, materialOptions, stars,mesh;

	init();
	animate();

	function init() {
		container = document.createElement('div');
		container.setAttribute("id", 'world')
		container.setAttribute("class", 'sky')
		document.body.appendChild( container );
		document.body.style.overflow = 'hidden';

		HEIGHT = window.innerHeight;
		WIDTH = window.innerWidth;
		aspectRatio = WIDTH / HEIGHT;
		fieldOfView = 75;
		nearPlane = 1;
		farPlane = 1000;
		mouseX = 0;
		mouseY = 0;

		windowHalfX = WIDTH / 2;
		windowHalfY = HEIGHT / 2;

	/* 	fieldOfView — Camera frustum vertical field of view.
			aspectRatio — Camera frustum aspect ratio.
			nearPlane — Camera frustum near plane.
			farPlane — Camera frustum far plane.

			- https://threejs.org/docs/#Reference/Cameras/PerspectiveCamera

		 	In geometry, a frustum (plural: frusta or frustums)
		 	is the portion of a solid (normally a cone or pyramid)
		 	that lies between two parallel planes cutting it. - wikipedia.		*/

		camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);

		//Z positioning of camera

		camera.position.z = farPlane / 2;

		scene = new THREE.Scene({antialias:true});
		scene.fog = new THREE.FogExp2( 0x000000, 0.0003 );

		// The wizard's about to get busy.
		starForge();

		//check for browser Support
		if (webGLSupport()) {
			//yeah?  Right on...
			renderer = new THREE.CanvasRenderer();

		} else {
			//No?  Well that's okay.
			renderer = new THREE.CanvasRenderer();
		}

		renderer.setClearColor(0x000011, 1);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize( WIDTH, HEIGHT);
		container.appendChild(renderer.domElement);







		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mousemove', onMouseMove, false );

	}

	function animate() {
		requestAnimationFrame(animate);
		render();

	}


	function render() {
		camera.position.x += ( mouseX - camera.position.x ) * 0.005;
		camera.position.y += ( - mouseY - camera.position.y ) * 0.005;
		mesh.rotation.y -= 0.005;
		camera.lookAt( scene.position );
		renderer.render(scene, camera);
	}

	function webGLSupport() {
		/* 	The wizard of webGL only bestows his gifts of power
			to the worthy.  In this case, users with browsers who 'get it'.		*/

		try {
			var canvas = document.createElement('canvas');
			return !!(window.WebGLRenderingContext && (
				canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
			);
		} catch(e) {
			// console.warn('Hey bro, for some reason we\'re not able to use webGL for this.  No biggie, we\'ll use canvas.');
			return false;
		}
	}

	function onWindowResize() {

		// Everything should resize nicely if it needs to!
	  	var WIDTH = window.innerWidth,
	  		HEIGHT = window.innerHeight;

	  	camera.aspect = aspectRatio;
	  	camera.updateProjectionMatrix();
	  	renderer.setSize(WIDTH, HEIGHT);
	}

	function starForge() {
		/* 	Yep, it's a Star Wars: Knights of the Old Republic reference,
			are you really surprised at this point?
													*/
		var starQty = 45000;
			geometry = new THREE.SphereGeometry(1000, 100, 50);

	    	materialOptions = {
	    		size: 1.0, //I know this is the default, it's for you.  Play with it if you want.
	    		transparency: true,
	    		opacity: 0.7
	    	};

	    	starStuff = new THREE.PointCloudMaterial(materialOptions);

		// The wizard gaze became stern, his jaw set, he creates the cosmos with a wave of his arms

		for (var i = 0; i < starQty; i++) {

			var starVertex = new THREE.Vector3();
			starVertex.x = Math.random() * 2000 - 1000;
			starVertex.y = Math.random() * 2000 - 1000;
			starVertex.z = Math.random() * 2000 - 1000;

			geometry.vertices.push(starVertex);

		}


		stars = new THREE.PointCloud(geometry, starStuff);
		scene.add(stars);


		var loader = new THREE.TextureLoader();

				loader.load( 'content/earth.jpg', function ( texture ) {

					var geometry = new THREE.SphereGeometry( 200, 20, 20 );

					var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
					 mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );

				} );
	}


	function onMouseMove(e) {

		mouseX = e.clientX - windowHalfX;
		mouseY = e.clientY - windowHalfY;
	}

})();
</script>




		<div id="container1" class="" style="display:none;">
			<nav></nav>
		</div>

		<script>
			var camera, scene, renderer;
			var texture_placeholder,
			isUserInteracting = false,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 90, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0,
			target = new THREE.Vector3();
			init();
			animate();
			function init() {
				var container1, mesh;
				container1 = document.getElementById( 'container1' );
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
				scene = new THREE.Scene();
				texture_placeholder = document.createElement( 'canvas' );
				texture_placeholder.width = 128;
				texture_placeholder.height = 128;
				var context = texture_placeholder.getContext( '2d' );
				context.fillStyle = 'rgb( 200, 200, 200 )';
				context.fillRect( 0, 0, texture_placeholder.width, texture_placeholder.height );
				var materials = [
					loadTexture( 'skybox/px.jpg' ), // right
					loadTexture( 'skybox/nx.jpg' ), // left
					loadTexture( 'skybox/py.jpg' ), // top
					loadTexture( 'skybox/ny.jpg' ), // bottom
					loadTexture( 'skybox/pz.jpg' ), // back
					loadTexture( 'skybox/nz.jpg' ) // front
				];
				mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), materials );
				mesh.scale.x = - 1;
				scene.add( mesh );
				for ( var i = 0, l = mesh.geometry.vertices.length; i < l; i ++ ) {
					var vertex = mesh.geometry.vertices[ i ];
					vertex.normalize();
					vertex.multiplyScalar( 550 );
				}
				renderer = new THREE.CanvasRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container1.appendChild( renderer.domElement );


				// document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				// document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				// document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				// document.addEventListener( 'wheel', onDocumentMouseWheel, false );
				// document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				// document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function loadTexture( path ) {
				var texture = new THREE.Texture( texture_placeholder );
				var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
				var image = new Image();
				image.onload = function () {
					texture.image = this;
					texture.needsUpdate = true;
				};
				image.src = path;
				return material;
			}

			// function onDocumentMouseDown( event ) {
			// 	event.preventDefault();
			// 	isUserInteracting = true;
			// 	onPointerDownPointerX = event.clientX;
			// 	onPointerDownPointerY = event.clientY;
			// 	onPointerDownLon = lon;
			// 	onPointerDownLat = lat;
			// }
			function onDocumentMouseMove( event ) {
				if ( isUserInteracting === true ) {
					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
				}
			}
			function onDocumentMouseUp( event ) {
				isUserInteracting = false;
			}
			function onDocumentMouseWheel( event ) {
				camera.fov += event.deltaY * 0.05;
				camera.updateProjectionMatrix();
			}
			function onDocumentTouchStart( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					onPointerDownPointerX = event.touches[ 0 ].pageX;
					onPointerDownPointerY = event.touches[ 0 ].pageY;
					onPointerDownLon = lon;
					onPointerDownLat = lat;
				}
			}
			function onDocumentTouchMove( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					lon = ( onPointerDownPointerX - event.touches[0].pageX ) * 0.1 + onPointerDownLon;
					lat = ( event.touches[0].pageY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
				}
			}
			function animate() {
				requestAnimationFrame( animate );
				update();
			}
			function update() {
				if ( isUserInteracting === false ) {
					lon += 0.3;
				}
				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.Math.degToRad( 90 - lat );
				theta = THREE.Math.degToRad( lon );
				target.x = 500 * Math.sin( phi ) * Math.cos( theta );
				target.y = 500 * Math.cos( phi );
				target.z = 500 * Math.sin( phi ) * Math.sin( theta );
				camera.position.copy( target ).negate();
				camera.lookAt( target );
				renderer.render( scene, camera );
			}
		// </script>
		<script type="text/javascript">

$('#openfirspage').on('click',()=>{

$('#world').fadeOut(1200,()=>{
	$('.row1').fadeOut();

$('#container1').fadeIn(1300);
$('.row2').fadeIn();

});


// $('#world').fadeOut(1000,()=>{
// 	$('.sky').fadeIn();


// });

});


</script>

	</body>






<%# ============================================================================================%>
